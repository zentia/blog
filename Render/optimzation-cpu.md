---
title: 性能优化，永无止境---CPU篇
date: 2018-03-05 10:13:10
tags:
	uwa
---
性能优化是游戏项目开发工程中一个永恒的话题。玩家的需求和项目的要求永远都在不停增长，同屏人数、屏幕特效和场景复杂度永远在向着”榨干“硬件的趋势毕竟。所以，无论硬件设备发展到何种成都，无论研发团队有多么丰富的经验积累，性能优化永远是一个非常棘手而又无法绕开的问题。

就当前游戏而言，性能优化主要是围着CPU、GPU和内存三大方面进行。下面，我们就这三方面说说当前移动游戏项目中存在的普遍问题的相应的解决方案。

# CPU方面
就目前的Unity移动游戏而言，CPU方面的性能开销主要可归结为两大类：引擎模块性能开销和自身代码性能开销。其中，引擎模块中又可细致划分为渲染模块、动画模块、物理模块、UI模块、粒子系统、加载模块和GC调用等等。正因如此，我们在UWA测评报告中，就这些模块进行详细的性能分析，以方便大家快速定位项目的性能瓶颈，同时，根据我们的分析和建议对问题进行迅速排查和解决。
通过大量的性能测评数据，我们发现渲染模块、UI模块和加载模块，往往占据了游戏CPU性能开销的Top3。

## 一、渲染模块

渲染模块可以说是任何游戏中最为消耗CPU性能的引擎模块，因为几乎所有的游戏都离不开场景、物体和特效的渲染。对于渲染模块的优化，主要从以下两个方面入手：

###（1）降低Draw Call

Draw Call是渲染模块优化方面的重中之重，一般来说，Draw Call越高，则渲染模块的CPU开销越大。究其原因，要从底层Driver和GPU的渲染流程讲起，限于篇幅我们不在这里做过的的介绍。https://stackoverflow.com/questions/4853856/why-are-draw-calls-expensive
降低Draw Call的方法则主要是减少所渲染物体的材质种类，并通过Draw Call Batching来减少其数量。Unity文档对于Draw Call Batching的原理和注意事项有非常详细的讲解。

但是，需要主要的是，游戏性能并非Draw Call越小越好。这是因为，决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的总线带宽。当我们使用Draw Call Batching将同种材质的网格模块拼合在一起，可能会造成同一时间需要传输的数据(Texture、VB/IB等)大大增加，以至于造成带宽"阻塞"，在资源无法及时传输过去的情况下，CPU只能等待，从而反倒降低了游戏的运行帧率。

Draw Call和总线带宽是天平的两端，我们需要做的是尽可能维持天平的平衡，任何一边过高或过低，对性能来说都是无益的。

### （2）简化资源

简化资源是非常行之有效的优化手段。在大量的移动中，其渲染资源其实是“过量”的，过量的网格资源、不合规的纹理资源等等。所以，我们在UWA测评报告中对资源的使用进行了详细的展示（每帧的三角形片数、网格和纹理资源的具体使用情况等），以帮助大家查找和完善存在问题的资源。

关于渲染模块在CPU方面的优化方法还有很多，比如LOD、Occlusion Culling和Culling Distance等等。我们会在后续的渲染模块技术专题中进行更为详细的讲解，敬请期待。

## 二、UI模块

UI模块同样也是几乎所有的游戏项目中必备的模块。一个性能优异的UI模块可以将用户体验在抬高一个档次。在目前国内的大量项目中，NGUI作为UI解决方案的占比仍然非常高。所以，UWA测评报告对NGUI的性能分析进行了极大的支持，我们会根据用户所使用的UI解决方案（UGUI或NGUI）的不同提供不同的性能分析和优化建议。

在NGUI的优化方面，UIPanel.LateUpdate为性能优化的重中之重，它是NGUI中CPU开销最大的函数，没有之一。UI模块制作的难点并不在于其表现上，因为UI界面的表现力是由设计师来决定的，但两套表现完全一直的UI系统，其底层的性能开销则可能千差万别。如何让UI系统使用尽可能小的CPU开销来达到设计师所设计的表现力，则足以考验每一位UI开发人员的制作功底。
对于UIPanel.LateUpdate的优化，主要着眼于UIPanel的布局，其原则如下：
- 尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中(UI的重建以UIPanel为单位)，从而尽可能将因为变动的UI模块引起的重构控制在较小的范围内；
- 尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中；
- 控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加，比如，战斗过程中的HUD运动血条可能会出现较多，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。

## 三、加载模块

加载模块同样也是任何游戏项目中所不可缺少的组成成分。与之前两个模块不同的是，加载模块的性能开销比较集中，主要出现于场景切换处，且CPU占用峰值均较高。

场景切换时的主要性能开销比较集中，主要出现于场景切换处，且CPU占用峰值均较高。

### 1.场景卸载

对于Unity引擎而言，场景卸载是由引擎自动完成的，即当我们调用类似Application.LoadLevel的API时，引擎即会开始对上一场景进行处理，其性能开销主要被以下几个部分占据：

- Destroy
	引擎再切换场景时会收集未标识成"DontDestoryOnLoad"的GameObject及其Component，然后进行Destroy。同时，代码中的OnDestroy被触发执行，这里的性能开销主要取决于OnDestroy回调函数中的代码逻辑。


