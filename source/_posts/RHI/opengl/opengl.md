---
title: OpenGL
date: 2018-04-01 11:24:55
categories:
- RHI
- OpenGL
---
https://learnopengl-cn.github.io/
# 基本概念
与读者以前听说的可能不同，OpenGL（对其它3D应用程序接口来说也是如此）3D图形编程并不都是关于着色器的。不管是使用C、C++、C#、JavaScript等编程语言的哪一种，客户端都必须完成相当多的工作，来管理这些着色器，以及向它们馈送（feed）几何图形、变换矩阵和其他各种数据。
本书的第一部分是真正的数据----3D图形编程教程，从基本原则开始讲述，当然这些都是基于实时3D图形渲染的行业标准OpenGL的。
着色器编程非常令人兴奋，但是作者并不打算将本书写成一本着色器编程数据。实际上，如果没有如何管理场景，设置视点、模型和变换矩阵，以及载入纹理等知识，那么即使懂得如何编写优秀的着色器也难有所成......我想读者一定明白我的意思。
为了帮助读者上手，本书提供了一个小型的“存储着色器”库，它们能够完成大多数常规任务。读者甚至可能会发现，对于简单3D渲染来说，这些着色器已经能够满足所有需要了。但是，随着知识的增长，读者可能并不会满足于此。在进入第二部分之前，还未读者准备GLSL“快速开始”，因此读者无需等到完成掌握OpenGL应用程序接口就能开始创造性了。
## 3D图形技术和术语
本书的每一章都包含一个或多个实例程序用来演示这一章锁讨论的编程技术。尽管本章有意避免了关于编程细节的讨论，但扔提供了一个示例程序向读者演示最低程度上需要熟悉的技术和术语，以帮助读者充分利用本书。本章的示例程序叫做BLOCK，读者可以从随书提供的示例程序集中的“Chapter 1”文件夹中找到它。
将数学和图形数据转换到3D空间图像的操作叫做渲染（Rendering）。当这个术语作为动词使用时，指的是计算机创建三维图像时所经历的过程。它也作为名词使用，指的仅仅是最终的图像作品。
### 光栅化（Rasterization）
实际绘制或填充每个定点之间的像素形成线段就叫做光栅化（Rasterization）。我们可以通过隐藏表面消除（Hidden Surface Removal）来进一步澄清3D设计意图。
视口：把绘图坐标映射到窗口坐标
裁剪区域的高度和宽度很少正好与窗口的宽度和高度（以像素为单位）相匹配。因此，坐标系统必须从逻辑笛卡尔坐标映射到物理屏幕像素坐标。这个映射是通过一种叫做视口（ViewPort）的设置来指定的。视口就是窗口内部用于绘制裁剪区域的客户区域。视口简单地把裁剪区域映射到窗口的一个区域。通常，视口被定义为整个窗口，但这并非严格必须的。例如，我们可能只希望在窗口的下半部分进行绘图。在用GPA抓帧的时候会发现，如果更改屏幕分辨率，就是只绘制到了视口或者窗口的一部分。
{% asset_img 1.jpg %}
与此形成对照的是，图1.20所示显示了一个与裁剪区域相匹配的视口。我们所看到的的这个窗口仍然是300*200像素。但是，现在可视区域将占据窗口的左下部分。
我们可以使用视口来缩小或放大窗口中的图像，也可以通过把视口设置为大于窗口的用户区域，从而只显示裁剪区域的一部分。
{% asset_img 2.jpg %}
顶点----空间中的一个位置

# 核心模式和立即渲染模式
早期的OpenGL使用**立即渲染模式**（Immediate mode，也就是**固定渲染管线**），立即渲染模式容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，推出核心模式(Core-profile)，这个模式完全移除了旧的特性。
# 状态机
OpenGL自身是一个巨大的状态机(State Machine)：一系列的变脸描述OpenGL此刻应当如何运行。绘制3D图形是一项复杂的任务。在接下来的章节，我们讨论许多OpenGL函数。对于一个特定的几何图形，有许多因素可能会影响它的绘制。对象是不是与背景混合？要不要进行正面或背面剔除？当前限制的是什么纹理？这样的问题数不胜数。

我们把这类变量的集合成为管线的状态。状态机是一个抽象的模型，表示一组状态变量的集合。每个状态变量可以有各种不同的值，或者只能可以打开或关闭等。当我们在OpenGL中进行绘图时，如果每次都要指定所有这些变量显示有点不切实际。反之，OpenGL使用了一种状态模型（或称状态机）来追踪所有的OpenGL状态变量。当一个状态值被设置之后，它就一直保持这个状态，直到其他函数对它进行修改为止。许多状态只能简单的打开或关闭。例如，深度测试（参见第3章）就是要么打开、要么关闭。打开深度测试的几何绘图将会被检查以确保在进行渲染之前总会在任何位于它后面的对象前方。在深度测试关闭后进行的几何图形绘制（例如2D覆盖）则会在不进行深度比较的情况下进行绘制。

为了打开这些类型的状态变量，可以使用下面这个OpenGL函数。
`void glEnable(GLenum capability);`
我们可以使用下面这个对应的函数，把这些变量的状态设置为关闭。
`void glDisable(GLenum capability);`
以深度测试为例，可以使用下面这个函数调用深度测试。
`glEnable(GL_DEPTH_TEST);`
也可以使用下面这个函数调用关闭深度测试。
`glDisable(GL_DEPTH_TEST);`
如果希望对一个状态变量进行测试，以判断它是否已被打开，OpenGL还提供了一种方便的机制。
`Glboolean glIsEnabled(GLenum capability);`
但是，并不是所有的状态变量都只是简单地打开或关闭。许多OpenGL函数专门用于设置变量的值，此后这些变量一直保持被设置时的值，直到再次被修改。我们在任何时候都可以查询这些变量的值。OpenGL提供了一组查询函数，可以查询布尔型、整型、单精度浮点型和双精度浮点型变量的值。这4个函数的原型如下所示：

# 颜色缓冲区

颜色缓冲区（COLOR_BUFFER）就是帧缓冲区（FRAME_BUFFER），你需要渲染的场景最终每一个像素都要写入该缓冲区，然后由它渲染到屏幕上显示。

# 深度缓冲区

深度缓冲区（DEPTH_BUFFER）与帧缓冲区对应，用于记录上面每个像素的深度值，通过深度缓冲区，我们就可以进行深度测试，从而确定像素的遮挡关系，保证渲染正确。

# 模版缓冲区

当片段着色器处理完片段之后，**模板测试（Stencil Test)**就开始执行了，和深度测试一样，它能丢弃一些片段。仍然保留下来的片段进入深度测试阶段，深度测试可能丢弃更多。模板测试基于另一个缓冲，这个缓冲叫做**模板缓冲（Stencil Buffer）**，我们被允许在渲染时更新它来获取有意思的效果。


# Texture Wrapping

通常，纹理坐标的范围在(0,0)到(1,1)之间，但是假如我们制定的坐标在这之外呢？
OpenGL会如何做出反应？默认情况下，OpenGL会重复绘制纹理图，不过，OpenGL也提供了更多的选择方案：

- GL_REPEAT：默认方案，重复纹理图片
- GL_MIRRORED_REPEAT：类似于默认方法，不过每次重复的时候进行镜像重复。
- GL_CLAMP_TP_EDGE：将坐标限制在0到1之间。超出的坐标会重复绘制边缘的像素，变成一种扩展边缘的图案。
- GL_CLAMP_TO_BORDER：超出的坐标将会被绘制成用户指定的边界颜色

## Mip贴图
Mip贴图是一种功能强大的纹理技巧，它不仅可以提高渲染性能，而且可以改善场景的显示质量。它使用标准纹理贴图处理两个常见的问题，从而实现上述目标。第一个问题是一种称为闪烁（Scintillation，即锯齿假影）的效果。当屏幕上被渲染物体的表面与它所应用的纹理图像相比显得非常小时，就会出现这种效果。闪烁可以被看成是某种类型的闪光，当纹理 图像的采样区域的移动幅度与它在屏幕上的大小相比显得不成比例时，就会发生这种现象。当照相机或物体处于运动状态时，我们很容易看到闪烁的负面效果。

第二个问题更多地和性能有关，但它的原因和闪烁相同。也就是说，问题的根源在与它必须加载大量的纹理内存并对它们进行过滤处理，但屏幕上实际显示的只是很少的一部分片段。纹理越大，这个问题造成的性能影响也就越为明显。

Mip贴图纹理由一系列图像组成，每个图像大小在每个轴的方向上都缩小一半，或者说是原来图像像素总数的四分之一。图5.11所示显示了这些场景。MipMap并不一样是正方形的，但每个图像的大小都依次减半，知道最后一个图像的大小是1 x 1的纹理单元位置。当其中一个纬度的大小到达1时，接下来的减半处理就只发生在其他纬度上了。使用一组正方形（即各个纬度的大小相等）的MipMap所要求的的内存比不使用MipMap要多出三分之一。
{% asset_img 3.jpg %}
MipMap是通过glTexImage函数加载的。现在轮到level参数发挥它的作用了，因为它指定了图像数据用于哪个Mip层。第一层是0，接着是1、2，然后依次类推。如果MipMap未被使用，那么就只有第0层会被加载。在默认情况下，为了使用MipMap，所有的Mip层都必须加载。但是我们可以用GL_TEXTURE_BASE_LEVEL和GL_TEXTURE_MAX_LEVEL纹理参数特别设置需要使用的基层和最大层。例如，如果想指定只加载从第0层至第4层，可以像下面这样调用glTexParameteri函数两次。
```c
glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_BASE_LEVEL,0);
glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAX_LEVEL,4);
```
尽管GL_TEXTURE_BASE_LEVEL和GL_TEXTURE_MAX_LEVEL控制哪些Mip层被加载，但我们仍然可以使用GL_TEXTURE_MIN_LOD和GL_TEXTURE_MAX_LOD参数限制已加载的Mip层的使用范围。
## MipMap过滤
MipMap在两个基本的纹理过滤模式GL_NEAREST和GL_LINEAR尚添加了一个新的变化，这是通过向Mip贴图过滤提供了4中不同变化实现的。表5.5列出了这些变化。
表5.5 经过MipMap的纹理过滤

|常量|描述|
|--|--|
|GL_NEAREST|在Mip基层上执行最邻近过滤|
|GL_LINER|在Mip基层上执行线性过滤|
|GL_NEAREST_MIPMAP_NEAREST|选择最邻近Mip层，并执行最邻近过滤|
|GL_NEAREST_MIPMAP_LINER|在Mip层之间执行线性插补，并执行最邻近过滤|
|GL_LINEAR_MIPMAP_LINEAR|在Mip层之间执行线性插补，并执行线性过滤，又称三线性Mip贴图|
仅仅使用glTexImage函数加载Mip层并不能启用Mip贴图功能。如果纹理过滤设置为GL_LINER或GL_NEAREST，那么就只有纹理贴图基层会被使用，其他所有加载的Mip层都将被忽略。我们必须制定其中一个Mip贴图过滤器，这样才能使用所有已加载的Mip层。这个常量具有GL_FILTER_MIPMAP_SELECTOR的形式，其中FILTER制定了被选择的Mip层将要使用的纹理过滤器，SELECTOR则制定了如何选择Mip层。例如，GL_NEAREST选择最接近匹配的Mip层。
应该选择哪种过滤器取决于具体的应用以及希望实现的性能要求。例如，GL_NEAREST_MIPMAP_NEAREST具有非常好的性能，并且闪烁现象也非常弱，但最邻近过滤在视觉效果上尝尝难以令人满意。GL_LINEAR_MIPMAP_NEAREST常常用于对游戏进行加载，因为它适用了更高质量的线性过滤器。但是，它需要在不同大小的可用Mip层之间进行快速选择（最邻近过滤）。

## 各向异性过滤
各向异性纹理过滤（Anisotropic texture filtering）并不是OpenGL核心规范的一部分，但它是一种得到广泛支持的扩展，可以极大地提高纹理过滤操作的质量。我们在本章前面内容中讲述了纹理贴图，并学习了两种最基本的纹理过滤：最邻近过滤（GL_NEAREST）和线性过滤（GL_LINEAR）。当一个纹理贴图被过滤时，OpenGL使用纹理坐标来判断一个特定的几何片段将落在纹理贴图的什么地方。然后，紧邻这个位置的纹理单元使用GL_NEAREST或GL_LINEAR过滤操作进行采样。

|常量|描述|
|--|--|
|GL_RGB|按照红、绿、蓝顺序排列的颜色|
|GL_RGBA|按照红、绿、Alpha顺序排列的颜色|

#  行主序和列主序
OpenGL中使用的矩阵，都是数学意义上的标准矩阵。但是各个OpenGL应用在实现矩阵时，根据存储方式的不同，分为两个派别：`行主序`和`列主序`。
`行主序`是指以行为优先单位，在内存中逐行存储。
`列主序`是指以列为优先单位，在内存中逐列存储。
