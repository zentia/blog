---
title: new delete malloc free
mathjax: true
date: 2019-04-10 11:34:54
tags:
    - C++
categories: C++
---
# 正文
每个程序在执行时都会占用一块可用的内存空间，用于存放动态分配的对象，此内存空间成为自由存储区或堆。

# new和delete用法

如下几行代码：

```c
int *pi = new int;
int *pi = new int();
int *pi = new int(1024);
```
第一行这个new表达式在自由存储区中分配创建了一个整型对象，并返回一个指向该对象的地址来初始化指针pi。第二行将指针pi指向的地址的值进行了初始化为0。第三行初始化为1024.
当动态创建的对象用完后必须释放内存，避免造成内存泄漏，可以用delete来完成，new和delete是成对使用的，如下命令释放pi指向的int型对象所占用的内存空间：
```c
delete pi;
```
此时pi尽管没有定义，但仍然存放了呃它所指向对象的地址，然而pi所指向的内存已经被释放，因此pi不再有效。建议一旦删除指针所指向的对象，立即将指针置为0，这样就清楚的表明指针不再指向任何对象。
```c
p = NULL;
```
值得注意的是当执行下列表达式：
```c
int pi = &i;
delete pi;
```
编译器一般不会报错，因为编译器通常不能断定一个指针指向什么类型的对象，所以尽管这个语句是错误的，但在大多数编译器上仍然能通过。
C++中允许动态创建const对象：
```c
const int *pi = new const int(1024);
```
动态创建的const对象必须进行初始化，并且进行初始化后的值不能在改变。
当创建一个动态数组对象和进行内存释放时，执行以下语句：
```c
int *pi = new int[];    // pi所指向的数组未初始化
int *pi = new int[n];   // pi指向长度为n的数组，未初始化
int *pi = new int[]();  // 指针pi所指向的地址初始化为0
delete [] pi;           // 回收pi所指向的数组
```

# malloc和free的用法

两个函数的原型如下，他们都在头文件stdlib.h中声明。
```c
void *malloc(size_t size);
void free(void *pointer);
```
示例代码如下：
```c
int *p = (int *)malloc(100);            // 指向整型的指针p指向一个大小为100字节的内存的地址
int *p = (int *)malloc(25*sizeof(int)); // 指向整型的指针p指向一个25个int整型空间的地址
```
因为malloc()函数的返回值类型为void *，所以需要在函数前面进行相应的强制类型转换。当int占4个字节内存时，上述的两个语句代码获得的内存空间大小是相同的。分配内存后需要验证内存是否分配成功，完成后free()释放内存，完整语句如下。
```c
int *p = (int *)malloc(int);
if (pi == NULL)
    printf("Out of memory!\n");
free(p);
```
另外两个分配内存的函数：calloc和realloc，他们的原型如下：
```c
void *calloc(size_t num_elements, size_t element_size);
void realloc(void *tr, size_t new_size);
```
malloc和calloc间的主要区别在于后者在返回指向内存的指针之前把它初始化为0。另一个区别是calloc的参数包括所需的元素的数量和每个元素的字节数。
relloc函数用于修改一个原先已经分配的内存块大小。可以使一块内存扩大或缩小，如果扩大内存，则原来的内存块保持不变，在内存尾部增加新的内存块，切不进行初始化。如果缩小内存，则原来内存块从尾部进行删减。如果原先的内存块无法扩充，则新开辟一块内存，并复制原先的内存的内容，原先内存块失效无法再进行访问。

# new和malloc的区别
## 属性
new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持c。
## 参数
使用new操作符申请内存分配时无须指定内存的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
## 返回类型
new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符号类型安全的操作符。而malloc内存分配成功则返回void *，需要通过强制类型转换将void *指针转换成我们需要的类型。
## 分配失败
new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时会返回NULL。
## 自定义类型
new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。
malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
## 重载
C++允许重载new/delete操作符，malloc不允许重载。
## 内存区域
new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统锁维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。

------------------------------------------------------------------------------------------------------------------------------------------

在C++/C#中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区；
在C中，内存区分为堆、栈、全局/静态存储区、常量存储区；