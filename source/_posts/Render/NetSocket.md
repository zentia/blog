---
title: IO多路复用之select、poll、epoll详解
date: 2019-03-02 13:19:19
tags:
- linux
---
目前支持I/O多路复用的系统调用有select,pselect,poll,epoll,I/O多路复用就是通过一种机制，一个进程可以监听多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），就能够通知程序进行相应的读写操作。但select,pselect,poll,epoll本质上都是同步I/O，因为他们都需要在读写时间就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这一步有性能开销）
与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减少了系统的开销。
# 使用场景
IO多路复用是指内核一旦发生进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：
1）当客户处理多个描述符时（一般是交互式输入和网络套接口），必须适用I/O复用。
2）当一个客户同时处理多个套接口，这种情况是可能的，但很少出现。（貌似没见过）
3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用I/O复用。（这是最常见的方式，貌似没有其他取代方式？）
4）如果一个服务器既要处理TCP，又要处理UDP，一般要使用I/O复用。
5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。
# select、poll、epoll简介
epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核都支持，其中epoll是Linux所特有，而select则应该是POSIX规定。
基本流程，如图所示：
{% asset_img netsocket1.png 这是一个新的博客的图片的说明 %}
select目前几乎在所有的平台上支持，其良好的跨平台支持也是它的一个优点。select的一个缺点在与单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。
select本质上是通过设置或者检查存放fb标志位的数据结构来进行下一步处理。这样所带来的的缺点是：
1.select最大的缺陷就是单个进程打开的DF是有一定限制的，它由FD_SETSIZE设置，默认值是1024。
一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max查看。32位默认1024个，64位默认2048个。我查了一下自己的虚拟机Centos6.0 是95979，从数量上分析来看，对于游戏来说，select模型个人感觉这点可以忽视了。
2.对socket进行扫描是线性扫描，即采用轮询的方法，效率较低。
当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。（这可太扯了）这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。
3.需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销很大。
## poll

poll是select的一种改良，最突出的改良有两点：
1.文件描述符数量没有上限
2.将输入输出参数进行分离，不用每次设定
缺点：
1.和select一样，poll返回后，需要轮询pollfd来获取就绪的描述符
2.每次调用poll都需要大把大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。
## epoll
1.文件描述符没有上限，通过epoll_ctl()来注册一个文件描述符，内核中使用红黑树的数据结构来管理所有需要监控的文件描述符。
2.基于时间就绪通知方式，一旦被监听的某个文件描述符就绪，内核会采用类似于callback的回调机制，迅速激活这个文件描述符，这样随着文件描述符数量的增加，也不会影响判定就绪的性能。
3.维护就绪队列，当文件描述符就绪，就会被放到内核中的一个就绪队列中，这样调用epoll_wait获取就绪文件描述符的时候，只要取队列中的元素即可，操作的时间复杂度恒为O(1)。
4.epoll内存映射机制，即内核将就绪队列通过mmap的方式映射到用户态，避免了拷贝内存这样的额外性能开销。