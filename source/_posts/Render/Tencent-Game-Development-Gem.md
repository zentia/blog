---
title: 腾讯游戏开发精粹
mathjax: true
date: 2019-09-02 12:02:25
tags:
categories:
---
# 基于SDF的摇杆移动
在当前MOBA手游中，移动方式大多采用摇杆移动，摇杆移动首先要解决的问题是与障碍物的碰撞检测，以及发生碰撞后如何行走（碰撞后直接停止的体验非常糟糕）。根据地图数据的不通，摇杆移动的碰撞检测方式有多重。
1. 物理碰撞方式：直接使用点（或圆）与多边形进行碰撞检测，然后绕多边形的边移动。
2. NavMesh方式：同样需要做点（或圆）与多边形碰撞检测，然后绕多边形的边移动。
3. 栅格方式：检测点是否在阻挡栅格内，或者圆与阻挡栅格的距离，碰撞后移动方向不好确定。

这里提供一种更为高效的且更为方便地解决其他移动相关需求的方案，即：基于SDF的摇杆移动。
SDF（Signed Distance Field）即有号距离场，表示空间中点到形状表面的最短距离，一般用正值表示形状外部，用负值表示形状内部。
{% asset_img 1.jpg %}
用数学公式表示，首先定义$\phi:R^n>R$对于一个形状点集S，有
{% asset_img 2.jpg %}
检测某点x是否在形状（障碍物）之内表示为：$/phi(x)\le 0$，如果预先知道每个店的有号距离$\phi(x)$，那么碰撞检测只需要一次查表即可。
因为SDF数据的生成较为耗时，因此需要预计算生成。顶视角MOBA游戏只需要做二维SDF计算，为减少数据存储量，先栅格化地图，通过点到多边形（障碍物）的距离离线计算栅格顶点的有号距离，从而生成SDF数据。运行时使用双线性过滤采样可以获得地图任意点的有号距离值，与角色碰撞半径比较判断是否和障碍物发生碰撞，检测过程只需查表和进行插值乘法计算，时间复杂度为O(1)。

SDF的梯度方向代表最大的变化方向，因此可以将梯度算子作为边界法线，当角色与障碍物发生碰撞后可沿着法线垂直方向滑行，同样可以根据梯度方向快速迭代来处理在MOBA游戏中击飞后"卡"在障碍物中的问题。对于瞬间位移（比如闪现）且不能穿越障碍物的需求，可以采用圆盘投射，以有号距离作为迭代补偿。对于AI寻路，SDF也可以通过修改探索函数（判断有号距离与碰撞半径的大小）来实现，且可以修改碰撞半径搜索贴近或远离障碍物的路径，打破寻路对称性。

前面讲到呃SDF是离线预生成的，那么对于MOBA游戏中动态障碍物的处理，可以使用程序式SDF和CSG运算来实现。不过，SDF在提高效率的同时也存在着存储空间大、较难动态更新（地形发生大的变化）的问题。

## 利用栅格数据预计算SDF
SDF 记录的是点到障碍物的距离，核心思想即空间换时间；如果动态计算点x的有号距离$\phi(x)$，那么复杂度跟物理碰撞检测的方案没什么区别。因此，我们需要预计算得到整张地图的SDF数据，因为不可能存储地图上所有的点，需要根据障碍精度对地图进行栅格化，比如主流MOBA游戏的5v5地图可以使用256x256栅格。
首先介绍一种基于栅格的SDF预计算方法。
根据场景障碍生成如图1.2所示的栅格地图，灰色表示阻挡，白色表示可行走区域。使用Meijster算法计算栅格中任意各自$(x,y)$到栅格阻挡区中最近各自的距离：
{% asset_img 3.jpg %}
图1.2 栅格地图
{% asset_img 4.jpg %}