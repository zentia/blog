---
title: 排序
date: 2019-02-25 20:45:21
mathjax: true
tags:
  - 数据结构与算法
---
# 快速排序
快速排序(Quick Sort)使用分治法策略。它的基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

一趟快速排序的算法是：
1. 设置两个变量i、j，排序开始的时候，i=0，j=N-1；
2. 以第一个数组元素作为关键数据，赋值给key，即key=A[0]
3. 从j开始向前搜索，即由后开始向前搜索（j--），找到第一个小于key的值A[j]，将A[j]=A[i]的值交换；
4. 从i开始向后搜索，即由钱开始向后搜索（i++），找到第一个大于key的值A[i]，将A[i]和A[j]的值交换；
5. 重复第3、4步，直到i=j；
```C++
void Sort(int *arr, int low, int high)
{
    if (low >= high)
        return;
    int i = low, j = high;
    int key = arr[i];
    while (true)
    {
        while (j > i)
        {
            if (key > arr[j])
            {
                break;
            }
            j--;
        }
        
        while (i < j)
        {
            if (key < arr[i])
            {
                break;
            }
            i++;
        }
        if (i >= j)break;
        int temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
    }
    int temp = arr[j];
    arr[j] = arr[low];
    arr[low] = temp;
    Sort(arr, low, i);
    Sort(arr, i + 1, high);
}
```
# 归并排序

## 基本思想

归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分支（divide-and-conquer）策略（分治法将问题分(divide)成一些小问题然后在递归求解，而治(conquer)的阶段则将分的阶段得到的各答案“修补”在一起，即分而治之）。

{% asset_img 1.png%}

可以看到这种结构很像一颗完全二叉树，本文的归并排序我们采用递归去实现，递归深度为$log_{2^n}$

## 合并相邻有序子序列

再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。

{% asset_img 2.png %}

## 复杂度

归并排序比较占用内存，但却是一种高效且稳定的算法。
时间复杂度：$O(n \cdot log^n)$
空间复杂度：T(n)

# 二叉堆（binary heap）

二叉堆是一种特殊的堆，二叉堆是完全二叉树（二叉树）或者近似完全二元树（二叉树）。二叉堆有两种：最小堆和最大堆。最大堆：父节点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。
