---
title: OpenGL ES 3.0 Fragment Shader
mathjax: true
date: 2019-09-04 14:22:23
tags:
    - "OpenGL ES 3.0"
categories: 
    - RHI
    - opengl
---
第9章介绍了在片段着色器中创建和应用纹理的基础知识。在本章中，我们提供了片段着色器的更多细节，并描述它的一些用户。特别是，我们聚焦于如何用片段着色器实现固定功能技术。本章介绍的主题包括：
- 固定功能片段着色器
- 可编程片段着色器概述
- 多重纹理
- 雾化
- Alpha测试
- 用户裁剪平面

{% asset_img 7.jpg %}

在图10-1中，已经包含了可编程管线的顶点着色器、图元装配和光栅化阶段。我们已经讨论了在片段着色器中使用纹理。现在，我们将重点放在管线的片段着色器部分，介绍片段着色器编写方面的其余细节。
# 固定功能片段着色器
对可编程片段管线还不熟悉但是已经使用过OpenGL ES 1.x的读者可能熟悉固定功能片段管线。在研究片段着色器的细节之前，我们认为值得简单地回顾一下老式的固定功能片段管线，这将帮助你理解老式的固定功能管线映射到片段着色器的方式。在转到更先进的片段编程技术之前，这是很好的起点。

在OpenGL ES 1.1中，可以使用一组有限的方程式，确定如何组合片段着色的不同输入。在固定功能管线中，实际上可以使用3种输入：插值顶点颜色、纹理颜色和常量颜色。顶点颜色通常保存一个预先计算的颜色或者顶点照明计算的结果。纹理颜色来自于使用图元纹理坐标绑定中读取的值，而常量颜色可以对每个纹理单元设置。

## 内建特殊变量
OpenGL ES 3.0有内建特殊变量，这些变量由片段着色器输出或者作为片段着色器的输入。片段着色器中可用的内建特殊变量如下所示：
- gl_FragCoord----片段着色器中的一个只读变量。这个变量保存片段的窗口相对坐标(x,y,z,1/w)。在一些算法中，知道当前片段的窗口坐标是很有用的。例如，可以使用窗口坐标作为某个随机噪声贴图纹理读取的偏移量，噪声贴图的值用于旋转阴影贴图的过滤核心。这种技术用于减少阴影贴图的锯齿失真。
- gl_FrontFacing----片段着色器中的一个只读变量。这个布尔变量在片段是正面图元的一部分时为true，否则为false。
- gl_PointCoord----一个只读变量，可以在渲染点精灵时使用。它保存点精灵的纹理坐标，这个坐标在点光栅化期间自动生成，处于[0,1]区间内。第14章中有一个使用该变量渲染点精灵的示例。
- gl_FragDepth----一个只写输出变量，在片段着色器中写入时，覆盖片段的固定功能深度值。这一个功能应该谨慎使用（只在必要时），因为它可能禁用许多GPU的深度优化。例如，许多GPU有所谓的“Early-Z”功能，在执行片段着色器之前进行深度测试。使用Early-Z的好处是不能通过深度测试的片段永远不回被着色（从而保护了性能）。但是，使用gl_FragDepth时，必须禁用该功能，因为GPU在执行片段着色器之前不知道深度值。

## 内建变量
下面是与片段着色器有关的内建变量：
```c
const mediump int gl_MaxFragmentInputVectors = 15;
const mediump int gl_MaxTextureImageUnits = 16;
const mediump int gl_MaxFragmentUniformVectors = 224;
const mediump int gl_MaxDrawBuffers = 4;
const mediump int gl_MinProgramTexelOffset = -8;
const mediump int gl_MaxProgramTexelOffset = 7;
```
内建常量描述如下最大项：
- gl_MaxFragmentInputVectors----片段着色器输入（或者可变值）的最大数量。所有ES 3.0实现支持的最小值为15。
- gl_MaxTextureImageUnits----可用纹理图像单元的最大数量。所有ES 3.0 实现支持的最小值为16。
- gl_MaxFragmentUniformVectors----片段着色器内可以使用vec4统一变量项目的最大数量。所有ES 3.0实现支持的最小值为224。开发者实际可以使用的vec4统一变量项目的数量在不同实现以及不同片段着色器可能不一样。这个问题在第8张中说明过，同样适用于片段着色器。
- gl_MaxDrawBuffers----多重渲染目标（MRT）的最大支持数量。所有ES 3.0实现支持的最小值为4。
- gl_MinProgramTexelOffset/gl_MaxProgramTexelOffset----通过内建ESSL函数texture*Offset()偏移参数支持的最大和最小偏移量。

## 多重纹理
我们从多重纹理入手，这是片段着色器中非常常见的操作，用于组合多个纹理贴图。例如，QuakeIII等多种游戏里曾经使用一种技术，将来自光照计算的照明效果存储在一个纹理贴图中。然后，这个贴图在片段着色器中与基本纹理贴图合并，以表现静态照明。多重纹理还有许多其他的示例，我们将在第14张介绍。例如，纹理贴图常常用于存储反射指数和遮罩，以衰减和遮盖反射光的分布。许多游戏还是用法线贴图，这种纹理以比逐顶点法线更高级别的细节存储法线信息，以便在片段着色器中计算照明。

## 雾化
应用雾化是渲染3D场景的一种常见技术。在OpenGL ES 1.1中，雾化作为一种固定功能操作。雾化如此普遍应用的原因之一是，它可以用于减少绘图距离，并且消除靠近观看者的几何体的“突现”现象。

雾化的计算有几种可能的方式，使用可编程片段着色器，你就不必局限于任何特定的方程式。下面我们将介绍如何用片段着色器计算线性雾化。要计算任何类型的雾化，需要两个输入：像素到眼睛的距离以及雾化的颜色。要计算线性雾化，还需要雾化所覆盖的最小和最大距离。

## 片段测试和操作

下面几个小节描述可以应用到OpenGL ES片段的各种测试。默认情况下，所有片段测试和操作都被禁用，片段在写入帧缓冲区时按照接受它们的顺序变成像素。通过启用不通的片段，可以应用操作性测试，以选择哪些片段成为像素并影响最终的图像。

每个片段测试都可以通过调用glEnable单独启用，该函数所带的标志参数如表11-1所示。

表11-1 片段测试启用标志

|glEnable标志|描述|
|--|--|
|GL_DEPTH_TEST|控制片段的深度测试|
|GL_STENCIL_TEST|控制片段的模版测试|
|GL_BLEND|控制片段与颜色缓冲区中存储的颜色的混合|
|GL_DITHER|在写入颜色颜色缓冲区前控制片段颜色的抖动|
|GL_SAMPLE_COVERAGE|控制样本范围值的计算|
|GL_SAMPLE_ALPHA_TO_COVERAGE|控制样本范围值计算中样本Alpha的使用|

## 使用裁剪测试
裁剪测试通过制定一个矩形区域（进一步限制帧缓冲区中可以写入的像素）提供了额外的裁剪层次。使用裁剪矩形是两步的过程。首先，需用glScissor函数指定矩形区域：
`void glScissor(GLint x, GLint y, GLsizei width, GLsizei height);`
x,y    以视口坐标指定裁剪矩形左下角
width  指定裁剪矩形宽度（以像素表示）
height 指定裁剪矩形高度（以像素显示）

指定裁剪矩形之后，需通过条用glEnable(GL_SCISSOR_TEST)启用它，以实施更多的裁剪。所有渲染（包括视口清除）都限于裁剪矩形之内。

一般来说，裁剪矩形是视口中的一个子区域，但是这两个区域不一定真正交叉。当两个区域不交叉时，裁剪操作将在视口区域外渲染的像素上进行。注意，视口的变换发生在片段着色器之前，而裁剪测试发生在片段着色器阶段之后。

## 模版缓冲区测试
应用到片段的下一个操作是模版测试。模版缓冲区是一个逐像素掩码，保存可用于确定某个像素是否应该被更新的值。模版测试由应用程序启用或者禁用。
模版缓冲区的使用可以看做两步的操作。第一步是用逐像素掩码初始化模版缓冲区，这可以通过渲染几何形状并制定模版缓冲区的更新方式来完成。第二部通常是使用这些值控制后续在颜色缓冲区中的渲染。在两种情况下，都制定参数在模版测试中的使用方式。

模版测试实际上是一个位测试，就像在C程序中使用掩码确定某一位是否置位一样。控制模版测试的运算符和值的模版函数由glStencilFunc或glStencilFuncSeparate函数控制。
`void glStencilFunc(GLenum func,GLint ref, GLuint mask)`
`void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)`
