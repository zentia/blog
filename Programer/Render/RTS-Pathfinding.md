---
title: RTS游戏中的寻路分析
mathjax: true
date: 2021-08-10 07:56:28
tags:
categories:
---
问题1：选取网格还是格子？
网格多用于RPG或者地图比较大的游戏，优点性能好，缺点，不利于快速编辑，每次更改地形都需要重新生成网格，切不利于可变的建筑物，做大世界的时候，基本也是固定的网格，然后在上面判断是否是通路。
格子寻路：不需要生成网格，只需要在每个格子确定是否是通路，相对于网格性能慢一些，不过也分场景，场景密集型但是小的话效率会高于网格，对于可变的建筑物做路通也很好做。
问题2：采用哪种寻路算法？
常见的寻路算法有：深度优先搜索(DFS)，广度优先搜索(BFS)，Dijkstra算法，贪婪优先最佳搜索，A*寻路算法，B*寻路算法，跳点寻路算法(Jump Point Search, JPS)
深度和广度优先搜索我们不说，因为基本不会用到，或者也是优化过的。
Dijkstra算法
Dijkstra在广度优先搜索的基础上增加了权重的概念。实现上构建了一张有向图，然后从起始点广度遍历周围的点，每次找到找到路径或者权重最小的点，这里的权重需要把之前的权重加起来，在围绕这个点重复做上述操作。
贪婪最佳优先搜索
由于Dijkstra是没有方向性的，可能出现搜索完整张图之后才能找到结果，由此出现了贪婪最佳优先搜索。首先贪心算法是带方向性的，其实理解起来很简单，只要把Dijkstra的cost或者权重或者最短路径的计算方式改一下就可以了，Dijkstra的cost 是根据当前点的周围点的最短距离求得，而贪婪最佳优先搜索则是根据当前点到目标点的距离求得，至于怎么求就看具体需求了，比如曼哈顿距离（不允许对角）欧几里得距离（直线距离）等。
贪婪最佳优先搜索和Dijkstra的区别是：前者是不完全搜索的，也就是基于目标去搜索，得到的结果不一定是最短路径，因为我们在遇到障碍物的时候是回退寻找当前点的次级距离终点的花费，并没有与其它路径作比较；后者是完全搜索的（因为要求出每一步的最短花费）。
A*算法
A*算法吸取了Dijkstra算法和贪婪最佳优先搜索的优点，即带有方向性的寻找起始点到当前点的最短花费，方向性的求解还是通过当前点和最终点的距离得知。
A*算法除了上述两个概念之外，还构造了两个列表，一个开放列表，一个关闭列表，就是从当前点遍历周围的邻接点，访问过的放到关闭列表，未访问的放到开放列表。
而带有方向性的的最短花费，就是将当前点到起始点的花费与当前点到终点的距离相加，然后找最小花费的点继续做这样的操作。
由于不是完全搜索，所以无法保证是最短路径。
B*算法
B*算法是一个很暴力的算法，什么距离花费的都不需要求，直接朝着目标点走就可以，即比较两点坐标，朝着终止点坐标走就可以了，当碰到障碍物的时候，沿着两边行走，即判断前行方向是否是障碍物，如果不是前进，如果是左右两边都走，就典型的贴边行走。因为简单粗暴的原因，所以效率最高。一般用于怪物的AI和寻路。
JPS/JPS+寻路算法
跳点寻路算法
首先A*寻路算法是根据开放列表去访问的，假如开放列表中的顶点数越少，那么效率越高，减少开放列表里的顶点的思维就叫做跳点，跳过一些顶点。
哪些点需要跳呢？
例如：无遮挡的情况下，可能会存在多条路径到重点的花费相同，这时候我们只需要选取一条就够了，还有，直线上面的点不需要放入开放列表，因为我们只需要直线的起始点和终止点就够了，对于这过程中的顶点不需要计算。
需要了解的概念：
强迫邻居

如上图，4和6为X的父顶点，就是当前点x的上一个寻路点，黑色的块为障碍物，那么3和1就是被圈中的为强迫邻居，就是父顶点想要去强迫邻居的时候，如果要绕开x点，那么会多花费的点。
跳点：
跳点满足一下三个条件之一：
1.节点x是起点/终点
2.节点x至少有一个强迫邻居
3.如果父节点在斜方向（意味着这是斜向搜索），节点x的水平或垂直方向又满足1或者2的点。
RTS群体寻路系统
一、什么是群体寻路

群体寻路通常被描述为在复杂地形中的多单位集体运动模型，其难点主要是在大规模的熏炉中如何在维持各单位相对独立性的同时，维护群体的完整性。
大规模的不对移动是许多游戏必须面对的一个挑战，特别是在RTS游戏中，经常需要面对几十上百个单位移动到同一地点的问题。这里面主要需要克服两个困难：
1.如何寻路？是整个部队作为一个整体进行寻路，还是各单位独立寻路？
2.如何避碰？面对可能导致寻路失败的单位碰撞、障碍物碰撞，要如何避免？
除此之外，一个寻路系统可能还需要满足以下几个要求：
1.高性能，RTS游戏中的地图较为复杂，需要处理的情况更多
2.扩展性，为游戏其他系统和模块留足设计空间
3.易编辑，方便高层级的Level Design
4.真实自然，能避开障碍物找到最优路线
5.动态避碰，当地形发生改变，或者突然出现其他单位的时候，不至于寻路失败


二、其他游戏的群体寻路

寻路系统在业内已经有许多比较成熟的解决方案，从早期的基于规则的方案到近些年基于算法的方法，下面将简单的介绍一下。
1.命令与征服（1995）：单位生成的路径只考虑从A点到B点的距离，忽略任何障碍物。这使得单位在移动时彼此重叠，在目的地才重新分开。
(1)所有单位每次都会计算一次最短路径
(2)如果两个单位在同一条导航路径上相遇，则会多次改变运动方向，以躲避其他单位
(3)群体寻路时，单位是互相重叠的，只有在抵达目的地后才会散开
2.魔兽争霸1&2：地图是以Tile为基础设计的，因为使用A*算法来寻找最优路径，但经常会遇到建筑物多占用了额外的Tile，导致寻路有瑕疵的问题。
(1)群体寻路时，若导航路径上出现新建筑或其他障碍物，则会导致导航路径失效。
(2)若在移动时，单位撞到了其他东西，则会向左或向右走，若一段时间后还没有找到就放弃
(3)若在移动时，单位遭受到攻击（或其他时间）则会离开原有的导航路径，执行其他AI行为
(4)单位之间经常发生碰撞，导致寻路失败，两个单位都无法移动
3.星际争霸1：改作沿用了魔兽争霸的引擎，但画面表现形式又与其不同，因此开发人员编写了大量的规则和设计了巨大的状态机来实现寻路系统，导致寻路系统性能急剧下降。
(1)群体寻路时，单位探测到前方路径上有其他单位，会暂时停止移动，等待其他单位移动过去，再继续沿着原来的路径移动。这能有效避免碰撞发生，但会浪费大量时间
(2)由于星际争霸1是基于魔兽争霸引擎开发的，因此其他方面基本与魔兽争霸相同
4.星际争霸2：使用了Flocking system with Flow Fields技术来实现群体寻路系统，通过计算每个单位的流畅来驱动单位移动，并通过Flocking Module来控制单位进行避障。
(1)群体寻路时，所有单位不会发生碰撞，不会发生重叠，不会突然的停顿
(2)多个群体互相穿插运动时，也能很流畅的进行避障，且维持一定的阵型，寻路结束后，所有群体完整完整性不会被破坏。
三、群体寻路是如何实现的
在早期的RTS游戏中，主要A*算法进行寻路，并基于规则进行避障。这种设计的缺点在于耗费大量的计算资源在寻路中，并需要编写大量的规则来实现动态避碰的效果。
Tile-based algorithm A* (A-Star)
由于寻路算法A*只考虑地形（修改后的A*也可以考虑游戏对象），它必须由一组规则来补充，这些规则根据游戏及其需要而变化。例如，在《魔兽争霸2》中，有一条规则：如果一个单位撞上了其他单位而不能滑过它们，它将重新寻找一条导航路径。这在少量单位的情况下工作良好，但是当试图在一条狭窄的通道中移动大量单位时，一些单位不可避免地会撞到他们前面的单位并试图重新搜索一条路径。
正如所见，这些规则非常有限。在某些情况下，他们必须牺牲一些更自然的行为来使整个系统正常运作。真正的最短路径算法会给游戏带来极大的麻烦，这是游戏设计者在选择算法时必须考虑的一个陷进。针对基于tile的A*算法在处理群体寻路时的局限性，提出了一种基于流场的群体运动系统（the Flocking System with Flow Fields），使群体寻路系统性能进一步的优化，在避碰效果上更加的自然。
Flow Fields + Flocking (or Swarm) Behavior
游戏《星际争霸2：自由之翼》和《最高指挥官2》以及大多数现代RTS游戏都使用带有流场的群集系统来维持对大部队的流体控制。在每个单元周围产生局部动态流畅。在调整群体运动之前，将群体的流畅合并在一起。
Pathfinding technique:Flow Fields
流场是另一种寻路的方法，这种方法对含有更多单位的群体更有效。流场是一个网格，其中每个网格正方形都有一个方向向量。这个矢量应该指向最有效的到达目的地的方向，同时避开静态障碍物。
Movement behavior:Flocking (or Swarm)
群集模型是由人工生成和计算机图形学专家克雷格·雷诺兹（Craig Regnolds）定义的。
群，根据定义，是一群一起巡航的鸟。雷诺兹将一般的模拟群实体成为”boids”，创建了biods人工生命模拟（1986）。基本的群集模型由三个简单的转向行为（分离、对齐和内聚）组成，这些行为描述了个体biod如何根据其附近群体的位置和速度移动。因此，群中的实体（或boids）以大致相同的速度巡航，在没有严格安排的情况下形成一个有凝聚力的群体。
该算法可以找到最少数量的导航节点，并允许单位自主控制转向行为顺利的绕过障碍物及其另据。从逻辑上将，每个单位都有传感器，当与另一个单位碰撞时，它会通知第一个单位转向适当的方向以避开另一个单位。
四、简单的架构设计
一个简单的群体寻路系统架构，通常可分为两层结构：
Pathfinding Module:以NavMesh & A*为主的寻路模块，获取群体/单位到目标位置的导航路径
Group Movement Module:群体移动模块，管理所有群体，及群体内的所有单位，单位在群体中表现出Flocking Behavior
在群体移动模块中，可通过设置规定一个群体是沿着同意的导航路径进行移动，还是各单位以松散的方式进行移动（但仍维持在同一个群体中）。
并且，在群体移动模块中，可以使用状态机来管理单位的移动，这样可以为后续的设计留下足够的空间，方便与其他AI系统进行交流。
通常，额可以用一个Group类来管理群体，删除/添加单位、设置振兴、设置群体目标等，还可以含有以下属性：
群体在保持一致的情况下可以移动的最大速度：这是由最慢的单位的速度决定的，或者最慢的单位在一个组中移动得更快一些，或者为了追赶而临时提高速度。
群体的质心：群体的参考点。
群体首领：为群体寻路并决定整个群体走哪条路线的单位。
群体振兴：群体中的所有单位以“首领”为中心，维持一定的相对位置

一个Units结构体来存储单位的信息，包括位置、群体信息、阵型信息和各种状态等，其中寻路运动状态为：
Wait for path:如果单位有一个有效的目标，则会向寻路模块请求一条路径。
Follow path:单位从路径的一个航路点移动到下一个航路点。此状态还管理单元的碰撞预测和避免。
Goal reached:当单位达到目标时，它将进入此状态。
Increase waypoint:当单位到达下一个地标时，该状态用路径的下一个航路点更新下一个地点。
五、动态避碰系统
解决了群体寻路、单位移动的问题后，还有一个非常重要的问题需要考虑，那就是动态避碰。一个实用、高性能的动避碰系统可以为游戏体验增色不少。
没有动态避碰，单位经常会发生寻路中发生碰撞导致寻路失败的情况。通常避碰系统有以下几种：
物理碰撞：当单位发生碰撞时，通过规则让单位实现避让的效果
速度避免：在速度空间中计算各单位的实时速度，从中选出在不会导致碰撞发生的速度，如RVO、ORCA算法
群集行为：利用类鸟群算法来模拟群体运动，实现碰撞避免效果
当然，大多数情况下只依靠一种算法是很难实现完美的、自然的避碰效果的。在实际开发中，通常需要结合寻路系统和地图情况来进行大量的修改优化，比如导航节点失效问题，运动抖动问题等。
RTS游戏中的避障算法
ORCA
论文：C:/Users/Jur van den Berg/Documents/ORCA/author.dvi (unc.edu)
Github: snape (Jamie Snape) · GitHub
官方文档：Optimal Reciprocal Collision Avoidance (ORCA) (unc.edu)
底层避障算法
1.VO(Velocity Obstacle)
2.RVO(Reciprocal Velocity Obstacle)
3.ORCA(Optimal Reciprocal Collision Avoidance)
在介绍VO，RVO，ORCA之前，需要先介绍路径规划
对Agent进行路径规划，实际上要完成的任务就是让Agent从点A无碰撞地移动到点B。而路径规划的过程层次化的，其基本框架大致如下：
High level:dijkstra、A*等寻路算法
Low level:VO,RVO,ORCA等底层避障算法。
很容易可以跟我们的日常生活进行类比，比如说我们要从学校的教学楼走到宿舍楼，那么以上框架对应的就是：
High level:通过dijkstra算法，得到路径为：教学楼-》饭堂-》体育馆-》图书馆-》宿舍楼
Low Level:通过底层避障算法如VO,RVO,ORCA等底层避障算法，保证我们走的每一段路（e.g.教学楼-》饭堂），都不会跟别的同学发生碰撞。
VO，RVO，ORCA就是经典的底层避障算法。其中VO是最经典的，RVO则在VO的基础上进行了一些改进，解决了VO抖动的问题。
跟RVO一样，ORCA也是基于VO的，但更加使用，因为：
效果上：考虑了速度的大小，使得筛选粒度更细，不想VO和RVO只考虑速度方向。
效率上：求解过程基本只用到了线性规划，比较高效。不像VO和RVO有大量的非线性求解。
ORCA介绍
ORCA是经典的分布式底层避障算法，其任务是（对于A）：

- 输入：A与B的形状($r_A$, $r_B$)、位置$(p_A, p_B)$、速度$(v_A, v_B)$，以及A的偏好量$(v_A^{pref})$

